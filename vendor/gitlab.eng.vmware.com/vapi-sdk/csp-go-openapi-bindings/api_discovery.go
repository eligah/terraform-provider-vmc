/*
 * Identity APIs
 *
 * A List of all identity and account management related APIs. Note: In order to use Bearer token as authentication method, you must include Bearer as a prefix to your token in the Authorize section.   Accepted format is: Bearer <authorization_token>
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapiclient

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// DiscoveryApiService DiscoveryApi service
type DiscoveryApiService service

// GetDiscoveryUsingGETOpts Optional parameters for the method 'GetDiscoveryUsingGET'
type GetDiscoveryUsingGETOpts struct {
    OrgLink optional.String
    Scope optional.String
    Nonce optional.String
    CodeChallenge optional.String
    CodeChallengeMethod optional.String
    Prompt optional.String
    LoginHint optional.String
    AccessTokenValiditySeconds optional.Int32
    RefreshTokenValiditySeconds optional.Int32
    MaxGroupsInIdToken optional.Int32
    Label optional.String
}

/*
GetDiscoveryUsingGET CSP Discovery login entry point (corresponds to OAuth 2.0 authorization endpoint)
This endpoint is used with browser redirection only. Trying to access it via GET HTTP call will fail. It discovers the user&#39;s Identity Provider (IdP) and sends the user to the IdP login page. This is the starting point of the OAuth 2.0 flow to authenticate end users from your application. This authorization endpoint must be used by clients to authenticate users and obtain an authorization code. To use this endpoint, your application must be registered as an OAuth 2.0 client with CSP and have the &#39;authorization_code&#39; grant type enabled.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clientId This is the identifier of the OAuth 2.0 client that was registered with CSP
 * @param redirectUri Specifies the callback endpoint in your application that will receive the authorization code. When sending the redirect_uri as a URL parameter it has to be URL encoded.
 * @param state A random string that your application generates and that will be sent back as a parameter during the URI redirection.
 * @param optional nil or *GetDiscoveryUsingGETOpts - Optional Parameters:
 * @param "OrgLink" (optional.String) -  The link to the organization the user is trying to access. If not provided, the user's default organization link will be used
 * @param "Scope" (optional.String) -  The list of scopes separated by a space and is URL encoded. Scope parameter can be used to request different scopes. The requested scope must not include any scope not originally granted. If omitted, the returned scopes will be the ones originally granted. 
 * @param "Nonce" (optional.String) -  A random value generated by the client and supplied in the authentication request that enables replay protection when present. The client should enforce protection against replay attacks by ensuring it is presented only once. The provided value will be returned in the id_token.
 * @param "CodeChallenge" (optional.String) -  The challenge generated from 'code_verifier'. Used to secure authorization code grants via Proof Key for Code Exchange (PKCE) from a native client. Required if performing a PKCE request. For more information, refer the PKCE RFC at https://tools.ietf.org/html/rfc7636
 * @param "CodeChallengeMethod" (optional.String) -  The method used to encode the 'code_verifier' for the 'code_challenge' parameter. Only the 'S256' value is supported currently. Required if performing a PKCE request. For more information, refer the PKCE RFC at https://tools.ietf.org/html/rfc7636
 * @param "Prompt" (optional.String) -  Specifies whether the Authorization Server prompts the End-User for re-authentication.
 * @param "LoginHint" (optional.String) -  Specifies to the Authorization Server about the login identifier the End-User might use to log in. When supplied, the discovery will be skipped, as if the value was entered by the user.<br><strong>Important:</strong><br><strong>1. If the user is already logged in with a different account than the provided login_hint it's value will be ignored.</strong><br><strong>2. The login_hint must be in a valid email format, otherwise, it will be ignored.</strong>
 * @param "AccessTokenValiditySeconds" (optional.Int32) -  The validity in seconds for the access token. If a value lower than the client's accessTokenValiditySeconds is provided, the provided accessTokenValiditySeconds value will be used. Else if an invalid value, a value higher than the client's accessTokenValiditySeconds, or no value is provided, then the client's accessTokenValiditySeconds will be used. For example if the client's default accessTokenValiditySeconds is 5 minutes ie 300 seconds, to get a token with only one minute validity provide accessTokenValiditySeconds as 60
 * @param "RefreshTokenValiditySeconds" (optional.Int32) -  The validity in seconds for the refresh token. If a value lower than the client's refreshTokenValiditySeconds is provided, the provided refreshTokenValiditySeconds value will be used. Else if an invalid value, a value higher than the client's refreshTokenValiditySeconds, or no value is provided, then the client's refreshTokenValiditySeconds will be used. For example if the client's default refreshTokenValiditySeconds is 30 minutes ie 1800 seconds, to get a token with one hour validity provide refreshTokenValiditySeconds as 3600
 * @param "MaxGroupsInIdToken" (optional.Int32) -  The maximum number of groups allowed in the ID token. If the value provided is lower than the client’s registered 'maxGroupsInIdToken’, the provided value will be used, else if an invalid value, a value higher than the client’s 'maxGroupsInIdToken’, or no value is provided, then the client’s ‘maxGroupsInIdToken’ will be used. This is only relevant if the client has registered groups related scopes such as 'group_names’, 'group_ids’, ‘grpn://…’ or 'grpid://…’.
 * @param "Label" (optional.String) -  The human readable label for the refresh token. It is an optional parameter that allows the caller to specify a label for a refresh token, to avoid displaying the refresh token value to the end user.
*/
func (a *DiscoveryApiService) GetDiscoveryUsingGET(ctx _context.Context, clientId string, redirectUri string, state string, localVarOptionals *GetDiscoveryUsingGETOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/discovery"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("client_id", parameterToString(clientId, ""))
	localVarQueryParams.Add("redirect_uri", parameterToString(redirectUri, ""))
	localVarQueryParams.Add("state", parameterToString(state, ""))
	if localVarOptionals != nil && localVarOptionals.OrgLink.IsSet() {
		localVarQueryParams.Add("orgLink", parameterToString(localVarOptionals.OrgLink.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarQueryParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Nonce.IsSet() {
		localVarQueryParams.Add("nonce", parameterToString(localVarOptionals.Nonce.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CodeChallenge.IsSet() {
		localVarQueryParams.Add("code_challenge", parameterToString(localVarOptionals.CodeChallenge.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CodeChallengeMethod.IsSet() {
		localVarQueryParams.Add("code_challenge_method", parameterToString(localVarOptionals.CodeChallengeMethod.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Prompt.IsSet() {
		localVarQueryParams.Add("prompt", parameterToString(localVarOptionals.Prompt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LoginHint.IsSet() {
		localVarQueryParams.Add("login_hint", parameterToString(localVarOptionals.LoginHint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccessTokenValiditySeconds.IsSet() {
		localVarQueryParams.Add("accessTokenValiditySeconds", parameterToString(localVarOptionals.AccessTokenValiditySeconds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RefreshTokenValiditySeconds.IsSet() {
		localVarQueryParams.Add("refreshTokenValiditySeconds", parameterToString(localVarOptionals.RefreshTokenValiditySeconds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxGroupsInIdToken.IsSet() {
		localVarQueryParams.Add("maxGroupsInIdToken", parameterToString(localVarOptionals.MaxGroupsInIdToken.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
