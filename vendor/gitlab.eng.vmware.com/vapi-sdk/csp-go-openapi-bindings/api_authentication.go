/*
 * Identity APIs
 *
 * A List of all identity and account management related APIs. Note: In order to use Bearer token as authentication method, you must include Bearer as a prefix to your token in the Authorize section.   Accepted format is: Bearer <authorization_token>
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapiclient

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// AuthenticationApiService AuthenticationApi service
type AuthenticationApiService service

/*
GetAccessTokenByApiRefreshTokenUsingPOST Exchange organization scoped API-token for user access token
The end-point is for exchanging organization scoped API-tokens only, that are obtained from the CSP web console. 1. Including the refresh token parameter using the application/x-www-form-urlencoded format in the HTTP request body. 2. DEPRECATED: Passing the refresh token via query param ### Access Policy: | Role | User Accounts | Service Accounts (Client Credentials Applications)  | | ----- | ----- | ---------- | | Anonymous | &amp;#x2714;&amp;#xFE0F; | &amp;#x2714;&amp;#xFE0F; | 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param refreshToken The API-token
@return AccessTokenDto
*/
func (a *AuthenticationApiService) GetAccessTokenByApiRefreshTokenUsingPOST(ctx _context.Context, refreshToken string) (AccessTokenDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccessTokenDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/am/api/auth/api-tokens/authorize"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("refresh_token", parameterToString(refreshToken, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetApiTokenDetailsUsingPOST Get organization scoped api token details
Get details of an unexpired org scoped API-token that was previously obtained via CSP web console. ### Access Policy: | Role | User Accounts | Service Accounts (Client Credentials Applications)  | | ----- | ----- | ---------- | | Anonymous | &amp;#x2714;&amp;#xFE0F; | &amp;#x2714;&amp;#xFE0F; | 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param request Get API Token Request
@return ApiTokenDetailsDto
*/
func (a *AuthenticationApiService) GetApiTokenDetailsUsingPOST(ctx _context.Context, request GetApiTokenDetailsRequest) (ApiTokenDetailsDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApiTokenDetailsDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/am/api/auth/api-tokens/details"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &request
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetPublicKeyUsingGETOpts Optional parameters for the method 'GetPublicKeyUsingGET'
type GetPublicKeyUsingGETOpts struct {
    Format optional.String
}

/*
GetPublicKeyUsingGET Get list of public keys in jwks format
Returns a list of public keys in jwks format. You should use this keys in your application to validate that the access-token is valid. The KID fields in the access-token is the ID of the public key. The PEM format is deprecated as it returns only the current active public key ### Access Policy: | Role | User Accounts | Service Accounts (Client Credentials Applications)  | | ----- | ----- | ---------- | | Anonymous | &amp;#x2714;&amp;#xFE0F; | &amp;#x2714;&amp;#xFE0F; | 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *GetPublicKeyUsingGETOpts - Optional Parameters:
 * @param "Format" (optional.String) -  The format for the key. Use the 'jwks' value for format. The PEM format is deprecated.
@return PublicKeyDto
*/
func (a *AuthenticationApiService) GetPublicKeyUsingGET(ctx _context.Context, localVarOptionals *GetPublicKeyUsingGETOpts) (PublicKeyDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PublicKeyDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/am/api/auth/token-public-key"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetTokenForAuthGrantTypeUsingPOSTOpts Optional parameters for the method 'GetTokenForAuthGrantTypeUsingPOST'
type GetTokenForAuthGrantTypeUsingPOSTOpts struct {
    Authorization optional.String
    Code optional.String
    RedirectUri optional.String
    RefreshToken optional.String
    Scope optional.String
    OrgId optional.String
    Username optional.String
    CodeVerifier optional.String
    Password optional.String
    AccessTokenValiditySeconds optional.Int32
    RefreshTokenValiditySeconds optional.Int32
    MaxGroupsInIdToken optional.Int32
}

/*
GetTokenForAuthGrantTypeUsingPOST Exchanges one of the following grants: authorization_code, refresh_token or client_credentials for access token
This end-point exchanges one of the following grants: authorization_code, refresh_token or client_credentials for access token 1. Include the parameters using application/x-www-form-urlencoded format in the HTTP request body. 2. Include Basic Base64_Encode(client_id:client_secret) value in the HTTP authorization header. Note: when using &lt;strong&gt;Public OAuth clients&lt;/strong&gt;, Authorization is required using the format &#39;Basic Base64_Encode(client_id:)&#39; with empty client_secret. Organization ID parameter notes: when organization id is missing from the request the default organization will be used. 1. Upon password grant type, user default organization will be set if available. 2. Upon client_credentials grant type, the organization who own the client will be set if available.  ### Access Policy: | Role | User Accounts | Service Accounts (Client Credentials Applications)  | | ----- | ----- | ---------- | | Anonymous | &amp;#x2714;&amp;#xFE0F; | &amp;#x2714;&amp;#xFE0F; | 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param grantType The grant type as per OAuth2 specification.
 * @param optional nil or *GetTokenForAuthGrantTypeUsingPOSTOpts - Optional Parameters:
 * @param "Authorization" (optional.String) -  Basic auth client credentials [Basic Base64_Encode(client_id:client_secret)]. Note: when using <strong>Public OAuth clients</strong>, Authorization is required using the format 'Basic Base64_Encode(client_id:)' with empty client_secret. 
 * @param "Code" (optional.String) -  Auth code parameter. Mandatory for grant_type 'authorization_code'
 * @param "RedirectUri" (optional.String) -  Service redirect uri. Mandatory for grant_type 'authorization_code'
 * @param "RefreshToken" (optional.String) -  Refresh token parameter. Available for grant_type 'refresh_token'
 * @param "Scope" (optional.String) -  The list of scopes separated by a space and is URL encoded. Scope parameter can be used to request different scopes. The requested scope must not include any scope not originally granted. If omitted, the returned scopes will be the ones originally granted. 
 * @param "OrgId" (optional.String) -  Organization ID. Available for grant_type 'client_credentials', 'password'
 * @param "Username" (optional.String) -  The username value corresponds to the value used when login to the system. Mandatory and available for grant_type 'password'
 * @param "CodeVerifier" (optional.String) -  A high-entropy cryptographic random key using the characters [A-Z] / [a-z] / [0-9] / '-' / '.' / '_' / '~' with a minimum length of 43 characters and a maximum length of 128 characters which was used to generate 'code_challenge' and obtain the authorization code. Required if PKCE was used in the authorization code grant request. For more information, refer the PKCE RFC at https://tools.ietf.org/html/rfc7636
 * @param "Password" (optional.String) -  The password of the user for whom the token should be returned. Mandatory and available for grant_type 'password'
 * @param "AccessTokenValiditySeconds" (optional.Int32) -  The validity in seconds for the access token. If a value lower than the client's accessTokenValiditySeconds is provided, the provided accessTokenValiditySeconds value will be used. Else if an invalid value, a value higher than the client's accessTokenValiditySeconds, or no value is provided, then the client's accessTokenValiditySeconds will be used. For example if the client's default accessTokenValiditySeconds is 5 minutes ie 300 seconds, to get a token with only one minute validity provide accessTokenValiditySeconds as 60
 * @param "RefreshTokenValiditySeconds" (optional.Int32) -  The validity in seconds for the refresh token. If a value lower than the client's refreshTokenValiditySeconds is provided, the provided refreshTokenValiditySeconds value will be used. Else if an invalid value, a value higher than the client's refreshTokenValiditySeconds, or no value is provided, then the client's refreshTokenValiditySeconds will be used. For example if the client's default refreshTokenValiditySeconds is 30 minutes ie 1800 seconds, to get a token with one hour validity provide refreshTokenValiditySeconds as 3600
 * @param "MaxGroupsInIdToken" (optional.Int32) -  The maximum number of groups allowed in the ID token. If the value provided is lower than the client’s registered 'maxGroupsInIdToken’, the provided value will be used, else if an invalid value, a value higher than the client’s 'maxGroupsInIdToken’, or no value is provided, then the client’s ‘maxGroupsInIdToken’ will be used. This is only relevant if the client has registered groups related scopes such as 'group_names’, 'group_ids’, ‘grpn://…’ or 'grpid://…’.
@return AccessTokenDto
*/
func (a *AuthenticationApiService) GetTokenForAuthGrantTypeUsingPOST(ctx _context.Context, grantType string, localVarOptionals *GetTokenForAuthGrantTypeUsingPOSTOpts) (AccessTokenDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccessTokenDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/am/api/auth/authorize"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Authorization.IsSet() {
		localVarHeaderParams["authorization"] = parameterToString(localVarOptionals.Authorization.Value(), "")
	}
	localVarFormParams.Add("grant_type", parameterToString(grantType, ""))
	if localVarOptionals != nil && localVarOptionals.Code.IsSet() {
		localVarFormParams.Add("code", parameterToString(localVarOptionals.Code.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RedirectUri.IsSet() {
		localVarFormParams.Add("redirect_uri", parameterToString(localVarOptionals.RedirectUri.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RefreshToken.IsSet() {
		localVarFormParams.Add("refresh_token", parameterToString(localVarOptionals.RefreshToken.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarFormParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgId.IsSet() {
		localVarFormParams.Add("orgId", parameterToString(localVarOptionals.OrgId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Username.IsSet() {
		localVarFormParams.Add("username", parameterToString(localVarOptionals.Username.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CodeVerifier.IsSet() {
		localVarFormParams.Add("code_verifier", parameterToString(localVarOptionals.CodeVerifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Password.IsSet() {
		localVarFormParams.Add("password", parameterToString(localVarOptionals.Password.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccessTokenValiditySeconds.IsSet() {
		localVarFormParams.Add("accessTokenValiditySeconds", parameterToString(localVarOptionals.AccessTokenValiditySeconds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RefreshTokenValiditySeconds.IsSet() {
		localVarFormParams.Add("refreshTokenValiditySeconds", parameterToString(localVarOptionals.RefreshTokenValiditySeconds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxGroupsInIdToken.IsSet() {
		localVarFormParams.Add("maxGroupsInIdToken", parameterToString(localVarOptionals.MaxGroupsInIdToken.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetTokenForAuthGrantTypeUsingPOST1Opts Optional parameters for the method 'GetTokenForAuthGrantTypeUsingPOST1'
type GetTokenForAuthGrantTypeUsingPOST1Opts struct {
    Authorization optional.String
    Code optional.String
    RedirectUri optional.String
    RefreshToken optional.String
    Scope optional.String
    OrgId optional.String
    Username optional.String
    CodeVerifier optional.String
    Password optional.String
    AccessTokenValiditySeconds optional.Int32
    RefreshTokenValiditySeconds optional.Int32
    MaxGroupsInIdToken optional.Int32
}

/*
GetTokenForAuthGrantTypeUsingPOST1 Exchanges one of the following grants: authorization_code, refresh_token or client_credentials for access token
This end-point exchanges one of the following grants: authorization_code, refresh_token or client_credentials for access token 1. Include the parameters using application/x-www-form-urlencoded format in the HTTP request body. 2. Include Basic Base64_Encode(client_id:client_secret) value in the HTTP authorization header. Note: when using &lt;strong&gt;Public OAuth clients&lt;/strong&gt;, Authorization is required using the format &#39;Basic Base64_Encode(client_id:)&#39; with empty client_secret. Organization ID parameter notes: when organization id is missing from the request the default organization will be used. 1. Upon password grant type, user default organization will be set if available. 2. Upon client_credentials grant type, the organization who own the client will be set if available.  ### Access Policy: | Role | User Accounts | Service Accounts (Client Credentials Applications)  | | ----- | ----- | ---------- | | Anonymous | &amp;#x2714;&amp;#xFE0F; | &amp;#x2714;&amp;#xFE0F; | 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param grantType The grant type as per OAuth2 specification.
 * @param optional nil or *GetTokenForAuthGrantTypeUsingPOST1Opts - Optional Parameters:
 * @param "Authorization" (optional.String) -  Basic auth client credentials [Basic Base64_Encode(client_id:client_secret)]. Note: when using <strong>Public OAuth clients</strong>, Authorization is required using the format 'Basic Base64_Encode(client_id:)' with empty client_secret. 
 * @param "Code" (optional.String) -  Auth code parameter. Mandatory for grant_type 'authorization_code'
 * @param "RedirectUri" (optional.String) -  Service redirect uri. Mandatory for grant_type 'authorization_code'
 * @param "RefreshToken" (optional.String) -  Refresh token parameter. Available for grant_type 'refresh_token'
 * @param "Scope" (optional.String) -  The list of scopes separated by a space and is URL encoded. Scope parameter can be used to request different scopes. The requested scope must not include any scope not originally granted. If omitted, the returned scopes will be the ones originally granted. 
 * @param "OrgId" (optional.String) -  Organization ID. Available for grant_type 'client_credentials', 'password'
 * @param "Username" (optional.String) -  The username value corresponds to the value used when login to the system. Mandatory and available for grant_type 'password'
 * @param "CodeVerifier" (optional.String) -  A high-entropy cryptographic random key using the characters [A-Z] / [a-z] / [0-9] / '-' / '.' / '_' / '~' with a minimum length of 43 characters and a maximum length of 128 characters which was used to generate 'code_challenge' and obtain the authorization code. Required if PKCE was used in the authorization code grant request. For more information, refer the PKCE RFC at https://tools.ietf.org/html/rfc7636
 * @param "Password" (optional.String) -  The password of the user for whom the token should be returned. Mandatory and available for grant_type 'password'
 * @param "AccessTokenValiditySeconds" (optional.Int32) -  The validity in seconds for the access token. If a value lower than the client's accessTokenValiditySeconds is provided, the provided accessTokenValiditySeconds value will be used. Else if an invalid value, a value higher than the client's accessTokenValiditySeconds, or no value is provided, then the client's accessTokenValiditySeconds will be used. For example if the client's default accessTokenValiditySeconds is 5 minutes ie 300 seconds, to get a token with only one minute validity provide accessTokenValiditySeconds as 60
 * @param "RefreshTokenValiditySeconds" (optional.Int32) -  The validity in seconds for the refresh token. If a value lower than the client's refreshTokenValiditySeconds is provided, the provided refreshTokenValiditySeconds value will be used. Else if an invalid value, a value higher than the client's refreshTokenValiditySeconds, or no value is provided, then the client's refreshTokenValiditySeconds will be used. For example if the client's default refreshTokenValiditySeconds is 30 minutes ie 1800 seconds, to get a token with one hour validity provide refreshTokenValiditySeconds as 3600
 * @param "MaxGroupsInIdToken" (optional.Int32) -  The maximum number of groups allowed in the ID token. If the value provided is lower than the client’s registered 'maxGroupsInIdToken’, the provided value will be used, else if an invalid value, a value higher than the client’s 'maxGroupsInIdToken’, or no value is provided, then the client’s ‘maxGroupsInIdToken’ will be used. This is only relevant if the client has registered groups related scopes such as 'group_names’, 'group_ids’, ‘grpn://…’ or 'grpid://…’.
@return AccessTokenDto
*/
func (a *AuthenticationApiService) GetTokenForAuthGrantTypeUsingPOST1(ctx _context.Context, grantType string, localVarOptionals *GetTokenForAuthGrantTypeUsingPOST1Opts) (AccessTokenDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccessTokenDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/am/api/auth/token"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Authorization.IsSet() {
		localVarHeaderParams["authorization"] = parameterToString(localVarOptionals.Authorization.Value(), "")
	}
	localVarFormParams.Add("grant_type", parameterToString(grantType, ""))
	if localVarOptionals != nil && localVarOptionals.Code.IsSet() {
		localVarFormParams.Add("code", parameterToString(localVarOptionals.Code.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RedirectUri.IsSet() {
		localVarFormParams.Add("redirect_uri", parameterToString(localVarOptionals.RedirectUri.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RefreshToken.IsSet() {
		localVarFormParams.Add("refresh_token", parameterToString(localVarOptionals.RefreshToken.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarFormParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrgId.IsSet() {
		localVarFormParams.Add("orgId", parameterToString(localVarOptionals.OrgId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Username.IsSet() {
		localVarFormParams.Add("username", parameterToString(localVarOptionals.Username.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CodeVerifier.IsSet() {
		localVarFormParams.Add("code_verifier", parameterToString(localVarOptionals.CodeVerifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Password.IsSet() {
		localVarFormParams.Add("password", parameterToString(localVarOptionals.Password.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccessTokenValiditySeconds.IsSet() {
		localVarFormParams.Add("accessTokenValiditySeconds", parameterToString(localVarOptionals.AccessTokenValiditySeconds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RefreshTokenValiditySeconds.IsSet() {
		localVarFormParams.Add("refreshTokenValiditySeconds", parameterToString(localVarOptionals.RefreshTokenValiditySeconds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxGroupsInIdToken.IsSet() {
		localVarFormParams.Add("maxGroupsInIdToken", parameterToString(localVarOptionals.MaxGroupsInIdToken.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetTokenIntrospectionDetailsUsingPOSTOpts Optional parameters for the method 'GetTokenIntrospectionDetailsUsingPOST'
type GetTokenIntrospectionDetailsUsingPOSTOpts struct {
    Authorization optional.String
}

/*
GetTokenIntrospectionDetailsUsingPOST Get refresh token details
The call is protected by HTTP Basic authentication with client_id and client_secret. Note: when using &lt;strong&gt;Public OAuth clients&lt;/strong&gt;, Authorization is required using the format &#39;Basic Base64_Encode(client_id:)&#39; with empty client_secret. This endpoint follows the token introspection specifications defined in https://tools.ietf.org/html/rfc7662. Only introspection of refresh tokens is supported. Include the parameter using application/x-www-form-urlencoded format in the HTTP request body.  ### Access Policy: | Role | User Accounts | Service Accounts (Client Credentials Applications)  | | ----- | ----- | ---------- | | Anonymous | &amp;#x2714;&amp;#xFE0F; | &amp;#x2714;&amp;#xFE0F; | 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param token The token to be introspected
 * @param optional nil or *GetTokenIntrospectionDetailsUsingPOSTOpts - Optional Parameters:
 * @param "Authorization" (optional.String) -  Basic auth with client credentials [Basic Base64_Encode(client_id:client_secret)] Note: when using <strong>Public OAuth clients</strong>, Authorization is required using the format 'Basic Base64_Encode(client_id:)' with empty client_secret. 
@return TokenIntrospectionResponse
*/
func (a *AuthenticationApiService) GetTokenIntrospectionDetailsUsingPOST(ctx _context.Context, token string, localVarOptionals *GetTokenIntrospectionDetailsUsingPOSTOpts) (TokenIntrospectionResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TokenIntrospectionResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/am/api/auth/introspect"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Authorization.IsSet() {
		localVarHeaderParams["authorization"] = parameterToString(localVarOptionals.Authorization.Value(), "")
	}
	localVarFormParams.Add("token", parameterToString(token, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// NewLogoutUsingPOSTOpts Optional parameters for the method 'NewLogoutUsingPOST'
type NewLogoutUsingPOSTOpts struct {
    IdTokenDto optional.Interface
}

/*
NewLogoutUsingPOST Return the identity provider logout url
This end-point returns the identity provider logout url. In order to logout, an explicit redirect to this url is needed ### Access Policy: | Role | User Accounts | Service Accounts (Client Credentials Applications)  | | ----- | ----- | ---------- | | Anonymous | &amp;#x2714;&amp;#xFE0F; | &amp;#x2714;&amp;#xFE0F; | 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NewLogoutUsingPOSTOpts - Optional Parameters:
 * @param "IdTokenDto" (optional.Interface of IdTokenDto) -  ID Token
@return UrlResponse
*/
func (a *AuthenticationApiService) NewLogoutUsingPOST(ctx _context.Context, localVarOptionals *NewLogoutUsingPOSTOpts) (UrlResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UrlResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/am/api/auth/logout"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.IdTokenDto.IsSet() {
		localVarOptionalIdTokenDto, localVarOptionalIdTokenDtook := localVarOptionals.IdTokenDto.Value().(IdTokenDto)
		if !localVarOptionalIdTokenDtook {
			return localVarReturnValue, nil, reportError("idTokenDto should be IdTokenDto")
		}
		localVarPostBody = &localVarOptionalIdTokenDto
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// RevokeTokenUsingPOSTOpts Optional parameters for the method 'RevokeTokenUsingPOST'
type RevokeTokenUsingPOSTOpts struct {
    Authorization optional.String
    Token optional.String
    TokenTypeHint optional.String
}

/*
RevokeTokenUsingPOST This end-point revokes a token
Only refresh tokens are supported at this time. 1. Include the parameters using application/x-www-form-urlencoded format in the HTTP request body. 2. Include Basic Base64_Encode(client_id:client_secret) value in the HTTP authorization header. Note: when using &lt;strong&gt;Public OAuth clients&lt;/strong&gt;, Authorization is required using the format &#39;Basic Base64_Encode(client_id:)&#39; with empty client_secret.  ### Access Policy: | Role | User Accounts | Service Accounts (Client Credentials Applications)  | | ----- | ----- | ---------- | | Anonymous | &amp;#x2714;&amp;#xFE0F; | &amp;#x2714;&amp;#xFE0F; | 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *RevokeTokenUsingPOSTOpts - Optional Parameters:
 * @param "Authorization" (optional.String) -  Basic auth client credentials [Basic Base64_Encode(client_id:client_secret)]. Note: when using <strong>Public OAuth clients</strong>, Authorization is required using the format 'Basic Base64_Encode(client_id:)' with empty client_secret. 
 * @param "Token" (optional.String) -  Token
 * @param "TokenTypeHint" (optional.String) -  Token type hint. In case not provided, refresh_token will be used.
*/
func (a *AuthenticationApiService) RevokeTokenUsingPOST(ctx _context.Context, localVarOptionals *RevokeTokenUsingPOSTOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/am/api/auth/revoke"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Authorization.IsSet() {
		localVarHeaderParams["authorization"] = parameterToString(localVarOptionals.Authorization.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.Token.IsSet() {
		localVarFormParams.Add("token", parameterToString(localVarOptionals.Token.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TokenTypeHint.IsSet() {
		localVarFormParams.Add("token_type_hint", parameterToString(localVarOptionals.TokenTypeHint.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
